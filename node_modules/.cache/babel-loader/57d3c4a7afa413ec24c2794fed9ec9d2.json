{"ast":null,"code":"var _ = require('underscore');\nvar _s = require('underscore.string');\nvar he = require('he');\nvar helper = require('./helper');\nfunction formatText(elem, options) {\n  var text = elem.data || \"\";\n  text = he.decode(text, options.decodeOptions);\n  if (options.isInPre) {\n    return text;\n  } else {\n    return helper.wordwrap(elem.trimLeadingSpace ? _s.lstrip(text) : text, options);\n  }\n}\nfunction formatImage(elem, options) {\n  if (options.ignoreImage) {\n    return '';\n  }\n  var result = '',\n    attribs = elem.attribs || {};\n  if (attribs.alt) {\n    result += he.decode(attribs.alt, options.decodeOptions);\n    if (attribs.src) {\n      result += ' ';\n    }\n  }\n  if (attribs.src) {\n    result += '[' + attribs.src + ']';\n  }\n  return result;\n}\nfunction formatLineBreak(elem, fn, options) {\n  return '\\n' + fn(elem.children, options);\n}\nfunction formatParagraph(elem, fn, options) {\n  return fn(elem.children, options) + '\\n\\n';\n}\nfunction formatHeading(elem, fn, options) {\n  var heading = fn(elem.children, options);\n  if (options.uppercaseHeadings) {\n    heading = heading.toUpperCase();\n  }\n  return heading + '\\n';\n}\n\n// If we have both href and anchor text, format it in a useful manner:\n// - \"anchor text [href]\"\n// Otherwise if we have only anchor text or an href, we return the part we have:\n// - \"anchor text\" or\n// - \"href\"\nfunction formatAnchor(elem, fn, options) {\n  var href = '';\n  // Always get the anchor text\n  var storedCharCount = options.lineCharCount;\n  var text = fn(elem.children || [], options);\n  if (!text) {\n    text = '';\n  }\n  var result = elem.trimLeadingSpace ? _s.lstrip(text) : text;\n  if (!options.ignoreHref) {\n    // Get the href, if present\n    if (elem.attribs && elem.attribs.href) {\n      href = elem.attribs.href.replace(/^mailto\\:/, '');\n    }\n    if (href) {\n      if (options.linkHrefBaseUrl && href.indexOf('/') == 0) {\n        href = options.linkHrefBaseUrl + href;\n      }\n      if (!options.hideLinkHrefIfSameAsText || href != _s.replaceAll(result, '\\n', '')) {\n        result += ' [' + href + ']';\n      }\n    }\n  }\n  options.lineCharCount = storedCharCount;\n  return formatText({\n    data: result || href,\n    trimLeadingSpace: elem.trimLeadingSpace\n  }, options);\n}\nfunction formatHorizontalLine(elem, fn, options) {\n  return '\\n' + _s.repeat('-', options.wordwrap) + '\\n\\n';\n}\nfunction formatListItem(prefix, elem, fn, options) {\n  options = _.clone(options);\n  // Reduce the wordwrap for sub elements.\n  if (options.wordwrap) {\n    options.wordwrap -= prefix.length;\n  }\n  // Process sub elements.\n  var text = fn(elem.children, options);\n  // Replace all line breaks with line break + prefix spacing.\n  text = text.replace(/\\n/g, '\\n' + _s.repeat(' ', prefix.length));\n  // Add first prefix and line break at the end.\n  return prefix + text + '\\n';\n}\nvar whiteSpaceRegex = /^\\s*$/;\nfunction formatUnorderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  _.each(nonWhiteSpaceChildren, function (elem) {\n    result += formatListItem(' * ', elem, fn, options);\n  });\n  return result + '\\n';\n}\nfunction formatOrderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  // Make sure there are list items present\n  if (nonWhiteSpaceChildren.length) {\n    // Calculate the maximum length to i.\n    var maxLength = nonWhiteSpaceChildren.length.toString().length;\n    _.each(nonWhiteSpaceChildren, function (elem, i) {\n      var index = i + 1;\n      // Calculate the needed spacing for nice indentation.\n      var spacing = maxLength - index.toString().length;\n      var prefix = ' ' + index + '. ' + _s.repeat(' ', spacing);\n      result += formatListItem(prefix, elem, fn, options);\n    });\n  }\n  return result + '\\n';\n}\nfunction tableToString(table) {\n  // Determine space width per column\n  // Convert all rows to lengths\n  var widths = _.map(table, function (row) {\n    return _.map(row, function (col) {\n      return col.length;\n    });\n  });\n  // Invert rows with colums\n  widths = helper.arrayZip(widths);\n  // Determine the max values for each column\n  widths = _.map(widths, function (col) {\n    return _.max(col);\n  });\n\n  // Build the table\n  var text = '';\n  _.each(table, function (row) {\n    var i = 0;\n    _.each(row, function (col) {\n      text += _s.rpad(_s.strip(col), widths[i++], ' ') + '   ';\n    });\n    text += '\\n';\n  });\n  return text + '\\n';\n}\nfunction formatTable(elem, fn, options) {\n  var table = [];\n  _.each(elem.children, tryParseRows);\n  return tableToString(table);\n  function tryParseRows(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    switch (elem.name.toLowerCase()) {\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"center\":\n        _.each(elem.children, tryParseRows);\n        return;\n      case 'tr':\n        var rows = [];\n        _.each(elem.children, function (elem) {\n          var tokens, times;\n          if (elem.type === 'tag') {\n            switch (elem.name.toLowerCase()) {\n              case 'th':\n                tokens = formatHeading(elem, fn, options).split('\\n');\n                rows.push(_.compact(tokens));\n                break;\n              case 'td':\n                tokens = fn(elem.children, options).split('\\n');\n                rows.push(_.compact(tokens));\n                // Fill colspans with empty values\n                if (elem.attribs && elem.attribs.colspan) {\n                  times = elem.attribs.colspan - 1 || 0;\n                  _.times(times, function () {\n                    rows.push(['']);\n                  });\n                }\n                break;\n            }\n          }\n        });\n        rows = helper.arrayZip(rows);\n        _.each(rows, function (row) {\n          row = _.map(row, function (col) {\n            return col || '';\n          });\n          table.push(row);\n        });\n        break;\n    }\n  }\n}\nexports.text = formatText;\nexports.image = formatImage;\nexports.lineBreak = formatLineBreak;\nexports.paragraph = formatParagraph;\nexports.anchor = formatAnchor;\nexports.heading = formatHeading;\nexports.table = formatTable;\nexports.orderedList = formatOrderedList;\nexports.unorderedList = formatUnorderedList;\nexports.listItem = formatListItem;\nexports.horizontalLine = formatHorizontalLine;","map":{"version":3,"names":["_","require","_s","he","helper","formatText","elem","options","text","data","decode","decodeOptions","isInPre","wordwrap","trimLeadingSpace","lstrip","formatImage","ignoreImage","result","attribs","alt","src","formatLineBreak","fn","children","formatParagraph","formatHeading","heading","uppercaseHeadings","toUpperCase","formatAnchor","href","storedCharCount","lineCharCount","ignoreHref","replace","linkHrefBaseUrl","indexOf","hideLinkHrefIfSameAsText","replaceAll","formatHorizontalLine","repeat","formatListItem","prefix","clone","length","whiteSpaceRegex","formatUnorderedList","nonWhiteSpaceChildren","filter","child","type","test","each","formatOrderedList","maxLength","toString","i","index","spacing","tableToString","table","widths","map","row","col","arrayZip","max","rpad","strip","formatTable","tryParseRows","name","toLowerCase","rows","tokens","times","split","push","compact","colspan","exports","image","lineBreak","paragraph","anchor","orderedList","unorderedList","listItem","horizontalLine"],"sources":["C:/frontend/node_modules/html-to-text/lib/formatter.js"],"sourcesContent":["var _ = require('underscore');\r\nvar _s = require('underscore.string');\r\nvar he = require('he');\r\n\r\nvar helper = require('./helper');\r\n\r\nfunction formatText(elem, options) {\r\n\tvar text = elem.data || \"\";\r\n\ttext = he.decode(text, options.decodeOptions);\r\n\r\n\tif (options.isInPre) {\r\n\t\treturn text;\r\n\t} else {\r\n\t\treturn helper.wordwrap(elem.trimLeadingSpace ? _s.lstrip(text) : text, options);\r\n\t}\r\n}\r\n\r\nfunction formatImage(elem, options) {\r\n\tif (options.ignoreImage) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tvar result = '', attribs = elem.attribs || {};\r\n\tif (attribs.alt) {\r\n\t\tresult += he.decode(attribs.alt, options.decodeOptions);\r\n\t\tif (attribs.src) {\r\n\t\t\tresult += ' ';\r\n\t\t}\r\n\t}\r\n\tif (attribs.src) {\r\n\t\tresult += '[' + attribs.src + ']';\r\n\t}\r\n\treturn (result);\r\n}\r\n\r\nfunction formatLineBreak(elem, fn, options) {\r\n\treturn '\\n' + fn(elem.children, options);\r\n}\r\n\r\nfunction formatParagraph(elem, fn, options) {\r\n\treturn fn(elem.children, options) + '\\n\\n';\r\n}\r\n\r\nfunction formatHeading(elem, fn, options) {\r\n\tvar heading = fn(elem.children, options);\r\n\tif (options.uppercaseHeadings) {\r\n\t\theading = heading.toUpperCase();\r\n\t}\r\n\treturn heading + '\\n';\r\n}\r\n\r\n// If we have both href and anchor text, format it in a useful manner:\r\n// - \"anchor text [href]\"\r\n// Otherwise if we have only anchor text or an href, we return the part we have:\r\n// - \"anchor text\" or\r\n// - \"href\"\r\nfunction formatAnchor(elem, fn, options) {\r\n\tvar href = '';\r\n\t// Always get the anchor text\r\n\tvar storedCharCount = options.lineCharCount;\r\n\tvar text = fn(elem.children || [], options);\r\n\tif (!text) {\r\n\t\ttext = '';\r\n\t}\r\n\r\n\tvar result = elem.trimLeadingSpace ? _s.lstrip(text) : text;\r\n\r\n\tif (!options.ignoreHref) {\r\n\t\t// Get the href, if present\r\n\t\tif (elem.attribs && elem.attribs.href) {\r\n\t\t\thref = elem.attribs.href.replace(/^mailto\\:/, '');\r\n\t\t}\r\n\t\tif (href) {\r\n\t\t\tif (options.linkHrefBaseUrl && href.indexOf('/') == 0) {\r\n\t\t\t\thref = options.linkHrefBaseUrl + href;\r\n\t\t\t}\r\n\t\t\tif (!options.hideLinkHrefIfSameAsText || href != _s.replaceAll(result, '\\n', '')) {\r\n\t\t\t\tresult += ' [' + href + ']';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\toptions.lineCharCount = storedCharCount;\r\n\r\n\treturn formatText({ data: result || href, trimLeadingSpace: elem.trimLeadingSpace }, options);\r\n}\r\n\r\nfunction formatHorizontalLine(elem, fn, options) {\r\n\treturn '\\n' + _s.repeat('-', options.wordwrap) + '\\n\\n';\r\n}\r\n\r\nfunction formatListItem(prefix, elem, fn, options) {\r\n\toptions = _.clone(options);\r\n\t// Reduce the wordwrap for sub elements.\r\n  if (options.wordwrap) {\r\n  \toptions.wordwrap -= prefix.length;\r\n  }\r\n\t// Process sub elements.\r\n\tvar text = fn(elem.children, options);\r\n\t// Replace all line breaks with line break + prefix spacing.\r\n\ttext = text.replace(/\\n/g, '\\n' + _s.repeat(' ', prefix.length));\r\n\t// Add first prefix and line break at the end.\r\n\treturn prefix + text + '\\n';\r\n}\r\n\r\nvar whiteSpaceRegex = /^\\s*$/;\r\n\r\nfunction formatUnorderedList(elem, fn, options) {\r\n\tvar result = '';\r\n\tvar nonWhiteSpaceChildren = (elem.children || []).filter(function(child) {\r\n\t\treturn child.type !== 'text' || !whiteSpaceRegex.test(child.data);\r\n\t});\r\n\t_.each(nonWhiteSpaceChildren, function(elem) {\r\n\t\tresult += formatListItem(' * ', elem, fn, options);\r\n\t});\r\n\treturn result + '\\n';\r\n}\r\n\r\nfunction formatOrderedList(elem, fn, options) {\r\n\tvar result = '';\r\n\tvar nonWhiteSpaceChildren = (elem.children || []).filter(function(child) {\r\n\t\treturn child.type !== 'text' || !whiteSpaceRegex.test(child.data);\r\n\t});\r\n\t// Make sure there are list items present\r\n\tif (nonWhiteSpaceChildren.length) {\r\n\t\t// Calculate the maximum length to i.\r\n\t\tvar maxLength = nonWhiteSpaceChildren.length.toString().length;\r\n\t\t_.each(nonWhiteSpaceChildren, function(elem, i) {\r\n\t\t\tvar index = i + 1;\r\n\t\t\t// Calculate the needed spacing for nice indentation.\r\n\t\t\tvar spacing = maxLength - index.toString().length;\r\n\t\t\tvar prefix = ' ' + index + '. ' + _s.repeat(' ', spacing);\r\n\t\t\tresult += formatListItem(prefix, elem, fn, options);\r\n\t\t});\r\n\t}\r\n\treturn result + '\\n';\r\n}\r\n\r\nfunction tableToString(table) {\r\n\t// Determine space width per column\r\n\t// Convert all rows to lengths\r\n\tvar widths = _.map(table, function(row) {\r\n\t\treturn _.map(row, function(col) {\r\n\t\t\treturn col.length;\r\n\t\t});\r\n\t});\r\n\t// Invert rows with colums\r\n\twidths = helper.arrayZip(widths);\r\n\t// Determine the max values for each column\r\n\twidths = _.map(widths, function(col) {\r\n\t\treturn _.max(col);\r\n\t});\r\n\r\n\t// Build the table\r\n\tvar text = '';\r\n\t_.each(table, function(row) {\r\n\t\tvar i = 0;\r\n\t\t_.each(row, function(col) {\r\n\t\t\ttext += _s.rpad(_s.strip(col), widths[i++], ' ') + '   ';\r\n\t\t});\r\n\t\ttext += '\\n';\r\n\t});\r\n\treturn text + '\\n';\r\n}\r\n\r\nfunction formatTable(elem, fn, options) {\r\n\tvar table = [];\r\n\t_.each(elem.children, tryParseRows);\r\n\treturn tableToString(table);\r\n\r\n\tfunction tryParseRows(elem) {\r\n\t\tif (elem.type !== 'tag') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tswitch (elem.name.toLowerCase()) {\r\n\t\t\tcase \"thead\":\r\n\t\t\tcase \"tbody\":\r\n\t\t\tcase \"tfoot\":\r\n\t\t\tcase \"center\":\r\n\t\t\t\t_.each(elem.children, tryParseRows);\r\n\t\t\t\treturn;\r\n\r\n\t\t\tcase 'tr':\r\n\t\t\t\tvar rows = [];\r\n\t\t\t\t_.each(elem.children, function(elem) {\r\n\t\t\t\t\tvar tokens, times;\r\n\t\t\t\t\tif (elem.type === 'tag') {\r\n\t\t\t\t\t\tswitch (elem.name.toLowerCase()) {\r\n\t\t\t\t\t\t\tcase 'th':\r\n\t\t\t\t\t\t\t\ttokens = formatHeading(elem, fn, options).split('\\n');\r\n\t\t\t\t\t\t\t\trows.push(_.compact(tokens));\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'td':\r\n\t\t\t\t\t\t\t\ttokens = fn(elem.children, options).split('\\n');\r\n\t\t\t\t\t\t\t\trows.push(_.compact(tokens));\r\n\t\t\t\t\t\t\t\t// Fill colspans with empty values\r\n\t\t\t\t\t\t\t\tif (elem.attribs && elem.attribs.colspan) {\r\n\t\t\t\t\t\t\t\t\ttimes = elem.attribs.colspan - 1 || 0;\r\n\t\t\t\t\t\t\t\t\t_.times(times, function() {\r\n\t\t\t\t\t\t\t\t\t\trows.push(['']);\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\trows = helper.arrayZip(rows);\r\n\t\t\t\t_.each(rows, function(row) {\r\n\t\t\t\t\trow = _.map(row, function(col) {\r\n\t\t\t\t\t\treturn col || '';\r\n\t\t\t\t\t});\r\n\t\t\t\t\ttable.push(row);\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexports.text = formatText;\r\nexports.image = formatImage;\r\nexports.lineBreak = formatLineBreak;\r\nexports.paragraph = formatParagraph;\r\nexports.anchor = formatAnchor;\r\nexports.heading = formatHeading;\r\nexports.table = formatTable;\r\nexports.orderedList = formatOrderedList;\r\nexports.unorderedList = formatUnorderedList;\r\nexports.listItem = formatListItem;\r\nexports.horizontalLine = formatHorizontalLine;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}