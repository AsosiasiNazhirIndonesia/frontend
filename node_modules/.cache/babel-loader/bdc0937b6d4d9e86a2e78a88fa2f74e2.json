{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\nvar account_1 = require(\"./account\");\nvar Address = /** @class */function () {\n  function Address(buf) {\n    (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\r\n   * Returns the zero address.\r\n   */\n  Address.zero = function () {\n    return new Address((0, bytes_1.zeros)(20));\n  };\n  /**\r\n   * Returns an Address object from a hex-encoded string.\r\n   * @param str - Hex-encoded address\r\n   */\n  Address.fromString = function (str) {\n    (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n    return new Address((0, bytes_1.toBuffer)(str));\n  };\n  /**\r\n   * Returns an address for a given public key.\r\n   * @param pubKey The two points of an uncompressed key\r\n   */\n  Address.fromPublicKey = function (pubKey) {\n    (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    var buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  };\n  /**\r\n   * Returns an address for a given private key.\r\n   * @param privateKey A private key must be 256 bits wide\r\n   */\n  Address.fromPrivateKey = function (privateKey) {\n    (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    var buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  };\n  /**\r\n   * Generates an address for a newly created contract.\r\n   * @param from The address which is creating this new address\r\n   * @param nonce The nonce of the from account\r\n   */\n  Address.generate = function (from, nonce) {\n    (0, assert_1.default)(externals_1.BN.isBN(nonce));\n    return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n  };\n  /**\r\n   * Generates an address for a contract created using CREATE2.\r\n   * @param from The address which is creating this new address\r\n   * @param salt A salt\r\n   * @param initCode The init code of the contract being created\r\n   */\n  Address.generate2 = function (from, salt, initCode) {\n    (0, assert_1.default)(Buffer.isBuffer(salt));\n    (0, assert_1.default)(Buffer.isBuffer(initCode));\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  };\n  /**\r\n   * Is address equal to another.\r\n   */\n  Address.prototype.equals = function (address) {\n    return this.buf.equals(address.buf);\n  };\n  /**\r\n   * Is address zero.\r\n   */\n  Address.prototype.isZero = function () {\n    return this.equals(Address.zero());\n  };\n  /**\r\n   * True if address is in the address range defined\r\n   * by EIP-1352\r\n   */\n  Address.prototype.isPrecompileOrSystemAddress = function () {\n    var addressBN = new externals_1.BN(this.buf);\n    var rangeMin = new externals_1.BN(0);\n    var rangeMax = new externals_1.BN('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  };\n  /**\r\n   * Returns hex encoding of address.\r\n   */\n  Address.prototype.toString = function () {\n    return '0x' + this.buf.toString('hex');\n  };\n  /**\r\n   * Returns Buffer representation of address.\r\n   */\n  Address.prototype.toBuffer = function () {\n    return Buffer.from(this.buf);\n  };\n  return Address;\n}();\nexports.Address = Address;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Address = void 0;\r\nvar assert_1 = __importDefault(require(\"assert\"));\r\nvar externals_1 = require(\"./externals\");\r\nvar bytes_1 = require(\"./bytes\");\r\nvar account_1 = require(\"./account\");\r\nvar Address = /** @class */ (function () {\r\n    function Address(buf) {\r\n        (0, assert_1.default)(buf.length === 20, 'Invalid address length');\r\n        this.buf = buf;\r\n    }\r\n    /**\r\n     * Returns the zero address.\r\n     */\r\n    Address.zero = function () {\r\n        return new Address((0, bytes_1.zeros)(20));\r\n    };\r\n    /**\r\n     * Returns an Address object from a hex-encoded string.\r\n     * @param str - Hex-encoded address\r\n     */\r\n    Address.fromString = function (str) {\r\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\r\n        return new Address((0, bytes_1.toBuffer)(str));\r\n    };\r\n    /**\r\n     * Returns an address for a given public key.\r\n     * @param pubKey The two points of an uncompressed key\r\n     */\r\n    Address.fromPublicKey = function (pubKey) {\r\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\r\n        var buf = (0, account_1.pubToAddress)(pubKey);\r\n        return new Address(buf);\r\n    };\r\n    /**\r\n     * Returns an address for a given private key.\r\n     * @param privateKey A private key must be 256 bits wide\r\n     */\r\n    Address.fromPrivateKey = function (privateKey) {\r\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\r\n        var buf = (0, account_1.privateToAddress)(privateKey);\r\n        return new Address(buf);\r\n    };\r\n    /**\r\n     * Generates an address for a newly created contract.\r\n     * @param from The address which is creating this new address\r\n     * @param nonce The nonce of the from account\r\n     */\r\n    Address.generate = function (from, nonce) {\r\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\r\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\r\n    };\r\n    /**\r\n     * Generates an address for a contract created using CREATE2.\r\n     * @param from The address which is creating this new address\r\n     * @param salt A salt\r\n     * @param initCode The init code of the contract being created\r\n     */\r\n    Address.generate2 = function (from, salt, initCode) {\r\n        (0, assert_1.default)(Buffer.isBuffer(salt));\r\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\r\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\r\n    };\r\n    /**\r\n     * Is address equal to another.\r\n     */\r\n    Address.prototype.equals = function (address) {\r\n        return this.buf.equals(address.buf);\r\n    };\r\n    /**\r\n     * Is address zero.\r\n     */\r\n    Address.prototype.isZero = function () {\r\n        return this.equals(Address.zero());\r\n    };\r\n    /**\r\n     * True if address is in the address range defined\r\n     * by EIP-1352\r\n     */\r\n    Address.prototype.isPrecompileOrSystemAddress = function () {\r\n        var addressBN = new externals_1.BN(this.buf);\r\n        var rangeMin = new externals_1.BN(0);\r\n        var rangeMax = new externals_1.BN('ffff', 'hex');\r\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\r\n    };\r\n    /**\r\n     * Returns hex encoding of address.\r\n     */\r\n    Address.prototype.toString = function () {\r\n        return '0x' + this.buf.toString('hex');\r\n    };\r\n    /**\r\n     * Returns Buffer representation of address.\r\n     */\r\n    Address.prototype.toBuffer = function () {\r\n        return Buffer.from(this.buf);\r\n    };\r\n    return Address;\r\n}());\r\nexports.Address = Address;\r\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}