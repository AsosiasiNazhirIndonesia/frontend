{"ast":null,"code":"\"use strict\";\n\nimport { HashZero } from \"@ethersproject/constants\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\nexport function formatBytes32String(text) {\n  // Get the bytes\n  const bytes = toUtf8Bytes(text);\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error(\"bytes32 string must be less than 32 bytes\");\n  }\n  // Zero-pad (implicitly null-terminates)\n  return hexlify(concat([bytes, HashZero]).slice(0, 32));\n}\nexport function parseBytes32String(bytes) {\n  const data = arrayify(bytes);\n  // Must be 32 bytes with a null-termination\n  if (data.length !== 32) {\n    throw new Error(\"invalid bytes32 - not 32 bytes long\");\n  }\n  if (data[31] !== 0) {\n    throw new Error(\"invalid bytes32 string - no null terminator\");\n  }\n  // Find the null termination\n  let length = 31;\n  while (data[length - 1] === 0) {\n    length--;\n  }\n  // Determine the string value\n  return toUtf8String(data.slice(0, length));\n}","map":{"version":3,"sources":["../src.ts/bytes32.ts"],"names":[],"mappings":"AAAA,YAAY;;AAEZ,SAAS,QAAQ,QAAQ,0BAA0B;AACnD,SAAS,QAAQ,EAAa,MAAM,EAAE,OAAO,QAAQ,sBAAsB;AAE3E,SAAS,WAAW,EAAE,YAAY,QAAQ,QAAQ;AAGlD,OAAM,SAAU,mBAAmB,CAAC,IAAY,EAAA;EAE5C;EACA,MAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC;EAE/B;EACA,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;IAAE,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC;EAAG;EAExF;EACA,OAAO,OAAO,CAAC,MAAM,CAAC,CAAE,KAAK,EAAE,QAAQ,CAAE,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC5D;AAEA,OAAM,SAAU,kBAAkB,CAAC,KAAgB,EAAA;EAC/C,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC;EAE5B;EACA,IAAI,IAAI,CAAC,MAAM,KAAK,EAAE,EAAE;IAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC;EAAG;EACnF,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE;IAAE,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC;EAAG;EAEvF;EACA,IAAI,MAAM,GAAG,EAAE;EACf,OAAO,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;IAAE,MAAM,EAAE;EAAG;EAE5C;EACA,OAAO,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AAC9C","sourceRoot":"","sourcesContent":["\"use strict\";\r\nimport { HashZero } from \"@ethersproject/constants\";\r\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\r\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\r\nexport function formatBytes32String(text) {\r\n    // Get the bytes\r\n    const bytes = toUtf8Bytes(text);\r\n    // Check we have room for null-termination\r\n    if (bytes.length > 31) {\r\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\r\n    }\r\n    // Zero-pad (implicitly null-terminates)\r\n    return hexlify(concat([bytes, HashZero]).slice(0, 32));\r\n}\r\nexport function parseBytes32String(bytes) {\r\n    const data = arrayify(bytes);\r\n    // Must be 32 bytes with a null-termination\r\n    if (data.length !== 32) {\r\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\r\n    }\r\n    if (data[31] !== 0) {\r\n        throw new Error(\"invalid bytes32 string - no null terminator\");\r\n    }\r\n    // Find the null termination\r\n    let length = 31;\r\n    while (data[length - 1] === 0) {\r\n        length--;\r\n    }\r\n    // Determine the string value\r\n    return toUtf8String(data.slice(0, length));\r\n}\r\n//# sourceMappingURL=bytes32.js.map"]},"metadata":{},"sourceType":"module"}