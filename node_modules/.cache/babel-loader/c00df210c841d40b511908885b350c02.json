{"ast":null,"code":"exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);\nexports.writableStream = isFunction(global.WritableStream);\nexports.abortController = isFunction(global.AbortController);\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr;\nfunction getXHR() {\n  // Cache the xhr value\n  if (xhr !== undefined) return xhr;\n  if (global.XMLHttpRequest) {\n    xhr = new global.XMLHttpRequest();\n    // If XDomainRequest is available (ie only, where xhr might not work\n    // cross domain), use the page location. Otherwise use example.com\n    // Note: this doesn't actually make an http request.\n    try {\n      xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');\n    } catch (e) {\n      xhr = null;\n    }\n  } else {\n    // Service workers don't have XHR\n    xhr = null;\n  }\n  return xhr;\n}\nfunction checkTypeSupport(type) {\n  var xhr = getXHR();\n  if (!xhr) return false;\n  try {\n    xhr.responseType = type;\n    return xhr.responseType === type;\n  } catch (e) {}\n  return false;\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer');\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream');\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer');\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\nxhr = null; // Help gc","map":{"version":3,"names":["exports","fetch","isFunction","global","ReadableStream","writableStream","WritableStream","abortController","AbortController","xhr","getXHR","undefined","XMLHttpRequest","open","XDomainRequest","e","checkTypeSupport","type","responseType","arraybuffer","msstream","mozchunkedarraybuffer","overrideMimeType","value"],"sources":["C:/spasi/frontend/node_modules/stream-http/lib/capability.js"],"sourcesContent":["exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\r\n\r\nexports.writableStream = isFunction(global.WritableStream)\r\n\r\nexports.abortController = isFunction(global.AbortController)\r\n\r\n// The xhr request to example.com may violate some restrictive CSP configurations,\r\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\r\n// and assume support for certain features below.\r\nvar xhr\r\nfunction getXHR () {\r\n\t// Cache the xhr value\r\n\tif (xhr !== undefined) return xhr\r\n\r\n\tif (global.XMLHttpRequest) {\r\n\t\txhr = new global.XMLHttpRequest()\r\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\r\n\t\t// cross domain), use the page location. Otherwise use example.com\r\n\t\t// Note: this doesn't actually make an http request.\r\n\t\ttry {\r\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\r\n\t\t} catch(e) {\r\n\t\t\txhr = null\r\n\t\t}\r\n\t} else {\r\n\t\t// Service workers don't have XHR\r\n\t\txhr = null\r\n\t}\r\n\treturn xhr\r\n}\r\n\r\nfunction checkTypeSupport (type) {\r\n\tvar xhr = getXHR()\r\n\tif (!xhr) return false\r\n\ttry {\r\n\t\txhr.responseType = type\r\n\t\treturn xhr.responseType === type\r\n\t} catch (e) {}\r\n\treturn false\r\n}\r\n\r\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\r\n// checkTypeSupport(), since that calls getXHR().\r\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\r\n\r\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\r\n// be used if it's available, just return false for these to avoid the warnings.\r\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\r\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\r\n\r\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\r\n// getXHR().\r\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\r\n\r\nfunction isFunction (value) {\r\n\treturn typeof value === 'function'\r\n}\r\n\r\nxhr = null // Help gc\r\n"],"mappings":"AAAAA,OAAO,CAACC,KAAK,GAAGC,UAAU,CAACC,MAAM,CAACF,KAAK,CAAC,IAAIC,UAAU,CAACC,MAAM,CAACC,cAAc,CAAC;AAE7EJ,OAAO,CAACK,cAAc,GAAGH,UAAU,CAACC,MAAM,CAACG,cAAc,CAAC;AAE1DN,OAAO,CAACO,eAAe,GAAGL,UAAU,CAACC,MAAM,CAACK,eAAe,CAAC;;AAE5D;AACA;AACA;AACA,IAAIC,GAAG;AACP,SAASC,MAAMA,CAAA,EAAI;EAClB;EACA,IAAID,GAAG,KAAKE,SAAS,EAAE,OAAOF,GAAG;EAEjC,IAAIN,MAAM,CAACS,cAAc,EAAE;IAC1BH,GAAG,GAAG,IAAIN,MAAM,CAACS,cAAc,EAAE;IACjC;IACA;IACA;IACA,IAAI;MACHH,GAAG,CAACI,IAAI,CAAC,KAAK,EAAEV,MAAM,CAACW,cAAc,GAAG,GAAG,GAAG,qBAAqB,CAAC;IACrE,CAAC,CAAC,OAAMC,CAAC,EAAE;MACVN,GAAG,GAAG,IAAI;IACX;EACD,CAAC,MAAM;IACN;IACAA,GAAG,GAAG,IAAI;EACX;EACA,OAAOA,GAAG;AACX;AAEA,SAASO,gBAAgBA,CAAEC,IAAI,EAAE;EAChC,IAAIR,GAAG,GAAGC,MAAM,EAAE;EAClB,IAAI,CAACD,GAAG,EAAE,OAAO,KAAK;EACtB,IAAI;IACHA,GAAG,CAACS,YAAY,GAAGD,IAAI;IACvB,OAAOR,GAAG,CAACS,YAAY,KAAKD,IAAI;EACjC,CAAC,CAAC,OAAOF,CAAC,EAAE,CAAC;EACb,OAAO,KAAK;AACb;;AAEA;AACA;AACAf,OAAO,CAACmB,WAAW,GAAGnB,OAAO,CAACC,KAAK,IAAIe,gBAAgB,CAAC,aAAa,CAAC;;AAEtE;AACA;AACAhB,OAAO,CAACoB,QAAQ,GAAG,CAACpB,OAAO,CAACC,KAAK,IAAIe,gBAAgB,CAAC,WAAW,CAAC;AAClEhB,OAAO,CAACqB,qBAAqB,GAAG,CAACrB,OAAO,CAACC,KAAK,IAAIe,gBAAgB,CAAC,yBAAyB,CAAC;;AAE7F;AACA;AACAhB,OAAO,CAACsB,gBAAgB,GAAGtB,OAAO,CAACC,KAAK,KAAKS,MAAM,EAAE,GAAGR,UAAU,CAACQ,MAAM,EAAE,CAACY,gBAAgB,CAAC,GAAG,KAAK,CAAC;AAEtG,SAASpB,UAAUA,CAAEqB,KAAK,EAAE;EAC3B,OAAO,OAAOA,KAAK,KAAK,UAAU;AACnC;AAEAd,GAAG,GAAG,IAAI,EAAC"},"metadata":{},"sourceType":"script"}