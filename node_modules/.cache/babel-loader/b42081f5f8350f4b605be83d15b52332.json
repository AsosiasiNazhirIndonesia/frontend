{"ast":null,"code":"var _ = require('underscore');\nvar _s = require('underscore.string');\n\n// Split a long word up to fit within the word wrap limit.  Use either a\n// character to split looking back from the word wrap limit, or\n// truncate to the word wrap limit.\nfunction splitLongWord(word, options) {\n  var wrapCharacters = options.longWordSplit.wrapCharacters || [];\n  var forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n  var max = options.wordwrap;\n  var fuseWord = [];\n  var idx = 0;\n  while (word.length > max) {\n    var firstLine = word.substr(0, max);\n    var remainingChars = word.substr(max);\n    var splitIndex = firstLine.lastIndexOf(wrapCharacters[idx]);\n    if (splitIndex > -1) {\n      // We've found a character to split on, store before the split then check if we\n      // need to split again\n      word = firstLine.substr(splitIndex + 1) + remainingChars;\n      fuseWord.push(firstLine.substr(0, splitIndex + 1));\n    } else {\n      idx++;\n      if (idx >= wrapCharacters.length) {\n        // Cannot split on character, so either split at 'max' or preserve length\n        if (forceWrapOnLimit) {\n          fuseWord.push(firstLine);\n          word = remainingChars;\n          if (word.length > max) {\n            continue;\n          }\n        } else {\n          word = firstLine + remainingChars;\n          if (!options.preserveNewlines) {\n            word += '\\n';\n          }\n        }\n        break;\n      } else {\n        word = firstLine + remainingChars;\n      }\n    }\n  }\n  fuseWord.push(word);\n  return fuseWord.join('\\n');\n}\nexports.wordwrap = function wordwrap(text, options) {\n  var max = options.wordwrap;\n  var preserveNewlines = options.preserveNewlines;\n  var length = options.lineCharCount;\n\n  // Preserve leading space\n  var result = _s.startsWith(text, ' ') ? ' ' : '';\n  length += result.length;\n  var buffer = [];\n  // Split the text into words, decide to preserve new lines or not.\n  var words = preserveNewlines ? text.replace(/\\n/g, '\\n ').split(/\\ +/) : _s.words(text);\n\n  // Determine where to end line word by word.\n  _.each(words, function (word) {\n    // Add buffer to result if we can't fit any more words in the buffer.\n    if ((max || max === 0) && length > 0 && (length + word.length > max || length + word.indexOf('\\n') > max)) {\n      // Concat buffer and add it to the result\n      result += buffer.join(' ') + '\\n';\n      // Reset buffer and length\n      buffer.length = length = 0;\n    }\n\n    // Check if the current word is long enough to be wrapped\n    if ((max || max === 0) && options.longWordSplit && word.length > max) {\n      word = splitLongWord(word, options);\n    }\n    buffer.push(word);\n\n    // If the word contains a newline then restart the count and add the buffer to the result\n    if (word.indexOf('\\n') != -1) {\n      result += buffer.join(' ');\n\n      // Reset the buffer, let the length include any characters after the last newline\n      buffer.length = 0;\n      length = word.length - (word.lastIndexOf('\\n') + 1);\n      // If there are characters after the newline, add a space and increase the length by 1\n      if (length) {\n        result += ' ';\n        length++;\n      }\n    } else {\n      // Add word length + one whitespace\n      length += word.length + 1;\n    }\n  });\n  // Add the rest to the result.\n  result += buffer.join(' ');\n\n  // Preserve trailing space\n  if (!_s.endsWith(text, ' ')) {\n    result = _s.rtrim(result);\n  } else if (!_s.endsWith(result, ' ')) {\n    result = result + ' ';\n  }\n  return result;\n};\nexports.arrayZip = function arrayZip(array) {\n  return _.zip.apply(_, array);\n};\nexports.splitCssSearchTag = function splitCssSearchTag(tagString) {\n  function getParams(re, string) {\n    var captures = [],\n      found;\n    while (found = re.exec(string)) {\n      captures.push(found[1]);\n    }\n    return captures;\n  }\n  var splitTag = {};\n  var elementRe = /(^\\w*)/g;\n  splitTag.element = elementRe.exec(tagString)[1];\n  splitTag.classes = getParams(/\\.([\\d\\w-]*)/g, tagString);\n  splitTag.ids = getParams(/#([\\d\\w-]*)/g, tagString);\n  return splitTag;\n};","map":{"version":3,"names":["_","require","_s","splitLongWord","word","options","wrapCharacters","longWordSplit","forceWrapOnLimit","max","wordwrap","fuseWord","idx","length","firstLine","substr","remainingChars","splitIndex","lastIndexOf","push","preserveNewlines","join","exports","text","lineCharCount","result","startsWith","buffer","words","replace","split","each","indexOf","endsWith","rtrim","arrayZip","array","zip","apply","splitCssSearchTag","tagString","getParams","re","string","captures","found","exec","splitTag","elementRe","element","classes","ids"],"sources":["C:/frontend/node_modules/html-to-text/lib/helper.js"],"sourcesContent":["var _ = require('underscore');\r\nvar _s = require('underscore.string');\r\n\r\n// Split a long word up to fit within the word wrap limit.  Use either a\r\n// character to split looking back from the word wrap limit, or\r\n// truncate to the word wrap limit.\r\nfunction splitLongWord(word, options) {\r\n    var wrapCharacters = options.longWordSplit.wrapCharacters || [];\r\n    var forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\r\n    var max = options.wordwrap;\r\n\r\n    var fuseWord = [];\r\n    var idx = 0;\r\n    while (word.length > max) {\r\n        var firstLine = word.substr(0, max);\r\n        var remainingChars = word.substr(max);\r\n\r\n        var splitIndex = firstLine.lastIndexOf(wrapCharacters[idx]);\r\n\r\n        if (splitIndex > -1) {\r\n            // We've found a character to split on, store before the split then check if we\r\n            // need to split again\r\n            word = firstLine.substr(splitIndex + 1) + remainingChars;\r\n            fuseWord.push(firstLine.substr(0, splitIndex + 1));\r\n        } else {\r\n            idx++;\r\n            if (idx >= wrapCharacters.length) {\r\n                // Cannot split on character, so either split at 'max' or preserve length\r\n                if (forceWrapOnLimit) {\r\n                    fuseWord.push(firstLine);\r\n                    word = remainingChars;\r\n                    if (word.length > max) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    word = firstLine + remainingChars;\r\n                    if (!options.preserveNewlines) {\r\n                        word += '\\n';\r\n                    }\r\n                }\r\n                break;\r\n            } else {\r\n                word = firstLine + remainingChars;\r\n            }\r\n        }\r\n    }\r\n    fuseWord.push(word);\r\n\r\n    return fuseWord.join('\\n');\r\n}\r\n\r\nexports.wordwrap = function wordwrap(text, options) {\r\n    var max = options.wordwrap;\r\n    var preserveNewlines = options.preserveNewlines;\r\n    var length = options.lineCharCount;\r\n\r\n    // Preserve leading space\r\n    var result = _s.startsWith(text, ' ') ? ' ' : '';\r\n    length += result.length;\r\n    var buffer = [];\r\n    // Split the text into words, decide to preserve new lines or not.\r\n    var words = preserveNewlines\r\n        ? text.replace(/\\n/g, '\\n ').split(/\\ +/)\r\n        : _s.words(text);\r\n\r\n    // Determine where to end line word by word.\r\n    _.each(words, function(word) {\r\n        // Add buffer to result if we can't fit any more words in the buffer.\r\n        if ((max || max === 0) && length > 0 &&\r\n            ((length + word.length > max) || (length + word.indexOf('\\n') > max)))\r\n        {\r\n            // Concat buffer and add it to the result\r\n            result += buffer.join(' ') + '\\n';\r\n            // Reset buffer and length\r\n            buffer.length = length = 0;\r\n        }\r\n\r\n        // Check if the current word is long enough to be wrapped\r\n        if ((max || max === 0) && (options.longWordSplit) && (word.length > max)) {\r\n            word = splitLongWord(word, options);\r\n        }\r\n\r\n        buffer.push(word);\r\n\r\n        // If the word contains a newline then restart the count and add the buffer to the result\r\n        if (word.indexOf('\\n') != -1) {\r\n            result += buffer.join(' ');\r\n\r\n            // Reset the buffer, let the length include any characters after the last newline\r\n            buffer.length = 0;\r\n            length = word.length - (word.lastIndexOf('\\n') + 1);\r\n            // If there are characters after the newline, add a space and increase the length by 1\r\n            if (length) {\r\n                result += ' ';\r\n                length++;\r\n            }\r\n        } else {\r\n            // Add word length + one whitespace\r\n            length += word.length + 1;\r\n        }\r\n    });\r\n    // Add the rest to the result.\r\n    result += buffer.join(' ');\r\n\r\n    // Preserve trailing space\r\n    if (!_s.endsWith(text, ' ')) {\r\n      result = _s.rtrim(result);\r\n    } else if (!_s.endsWith(result, ' ')) {\r\n      result = result + ' ';\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexports.arrayZip = function arrayZip(array) {\r\n    return _.zip.apply(_, array);\r\n};\r\n\r\nexports.splitCssSearchTag = function splitCssSearchTag(tagString) {\r\n    function getParams(re, string) {\r\n        var captures = [], found;\r\n        while (found = re.exec(string)) {\r\n            captures.push(found[1]);\r\n        }\r\n        return captures;\r\n    }\r\n\r\n    var splitTag = {};\r\n    var elementRe = /(^\\w*)/g;\r\n    splitTag.element = elementRe.exec(tagString)[1];\r\n    splitTag.classes = getParams( /\\.([\\d\\w-]*)/g, tagString);\r\n    splitTag.ids = getParams( /#([\\d\\w-]*)/g, tagString);\r\n\r\n    return splitTag;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}