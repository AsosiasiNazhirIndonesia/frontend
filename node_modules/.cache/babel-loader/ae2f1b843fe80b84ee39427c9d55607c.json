{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nvar externals_1 = require(\"./externals\");\nvar internal_1 = require(\"./internal\");\nvar bytes_1 = require(\"./bytes\");\n/**\r\n * Convert BN to 0x-prefixed hex string.\r\n */\nfunction bnToHex(value) {\n  return \"0x\".concat(value.toString(16));\n}\nexports.bnToHex = bnToHex;\n/**\r\n * Convert value from BN to an unpadded Buffer\r\n * (useful for RLP transport)\r\n * @param value value to convert\r\n */\nfunction bnToUnpaddedBuffer(value) {\n  // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n  // for compatibility with browserify and similar tools\n  return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\r\n * Deprecated alias for {@link bnToUnpaddedBuffer}\r\n * @deprecated\r\n */\nfunction bnToRlp(value) {\n  return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\r\n * Type output options\r\n */\nvar TypeOutput;\n(function (TypeOutput) {\n  TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n  TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n  TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n  TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n  if (input === null) {\n    return null;\n  }\n  if (input === undefined) {\n    return undefined;\n  }\n  if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n    throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n  var output = (0, bytes_1.toBuffer)(input);\n  if (outputType === TypeOutput.Buffer) {\n    return output;\n  } else if (outputType === TypeOutput.BN) {\n    return new externals_1.BN(output);\n  } else if (outputType === TypeOutput.Number) {\n    var bn = new externals_1.BN(output);\n    var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n    if (bn.gt(max)) {\n      throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n    }\n    return bn.toNumber();\n  } else {\n    // outputType === TypeOutput.PrefixedHexString\n    return \"0x\".concat(output.toString('hex'));\n  }\n}\nexports.toType = toType;","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\r\nvar externals_1 = require(\"./externals\");\r\nvar internal_1 = require(\"./internal\");\r\nvar bytes_1 = require(\"./bytes\");\r\n/**\r\n * Convert BN to 0x-prefixed hex string.\r\n */\r\nfunction bnToHex(value) {\r\n    return \"0x\".concat(value.toString(16));\r\n}\r\nexports.bnToHex = bnToHex;\r\n/**\r\n * Convert value from BN to an unpadded Buffer\r\n * (useful for RLP transport)\r\n * @param value value to convert\r\n */\r\nfunction bnToUnpaddedBuffer(value) {\r\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\r\n    // for compatibility with browserify and similar tools\r\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\r\n}\r\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\r\n/**\r\n * Deprecated alias for {@link bnToUnpaddedBuffer}\r\n * @deprecated\r\n */\r\nfunction bnToRlp(value) {\r\n    return bnToUnpaddedBuffer(value);\r\n}\r\nexports.bnToRlp = bnToRlp;\r\n/**\r\n * Type output options\r\n */\r\nvar TypeOutput;\r\n(function (TypeOutput) {\r\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\r\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\r\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\r\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\r\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\r\nfunction toType(input, outputType) {\r\n    if (input === null) {\r\n        return null;\r\n    }\r\n    if (input === undefined) {\r\n        return undefined;\r\n    }\r\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\r\n        throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\r\n    }\r\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\r\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\r\n    }\r\n    var output = (0, bytes_1.toBuffer)(input);\r\n    if (outputType === TypeOutput.Buffer) {\r\n        return output;\r\n    }\r\n    else if (outputType === TypeOutput.BN) {\r\n        return new externals_1.BN(output);\r\n    }\r\n    else if (outputType === TypeOutput.Number) {\r\n        var bn = new externals_1.BN(output);\r\n        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\r\n        if (bn.gt(max)) {\r\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\r\n        }\r\n        return bn.toNumber();\r\n    }\r\n    else {\r\n        // outputType === TypeOutput.PrefixedHexString\r\n        return \"0x\".concat(output.toString('hex'));\r\n    }\r\n}\r\nexports.toType = toType;\r\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}